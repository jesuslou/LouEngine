import sys
import os
from stat import S_IWUSR
import argparse
import subprocess
from subprocess import DEVNULL
import importlib


VALID_FRAMEWORKS = ["none", "sfml", "sdl"]

def path_to_os(path):
	full_path = os.path.abspath(path)
	parts = full_path.split("/")
	return os.path.sep.join(parts)

def remove_folder_recursively(path_to_folder):
	path_to_folder_exists = os.path.isdir(path_to_folder)
	if path_to_folder_exists:
		print("removing " + path_to_folder)
		if os.path.isdir(path_to_folder):
			for root, dirs, files in os.walk(path_to_folder, topdown=False):
				for name in files:
					filename = os.path.join(root, name)
					os.chmod(filename, S_IWUSR)
					os.remove(filename)
				for name in dirs:
					os.rmdir(os.path.join(root, name))
			os.rmdir(path_to_folder)

def message_and_die(message):
	print('\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
	print(message)
	print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
	sys.exit(1)

def check_git_in_path():
	if subprocess.call('git --version', shell=True, stdout=DEVNULL, stderr=DEVNULL) != 0:
		message_and_die('Git executable "git" not in your path')

def check_cmake_in_path():
	if subprocess.call('cmake --version', shell=True, stdout=DEVNULL, stderr=DEVNULL) != 0:
		message_and_die('CMake executable "cmake" not in your path')

def read_parameters():
	parser = argparse.ArgumentParser()
	parser.add_argument('-n', '--name', required=True, help="Project's name")
	parser.add_argument('-d', '--deploy_path', default=".", help='Path where the project will be created under folder with name -n/--name')
	parser.add_argument('-r', '--remote', default="none", help='Remote to initialize the project in')
	parser.add_argument('-p', '--push', action='store_true', help='whether the changes will be pushed to the specified remote')
	parser.add_argument('-g', '--generate', choices=VALID_FRAMEWORKS, default="none", help='Generate the solution when finished for one of [{}]'.format(''.join(VALID_FRAMEWORKS)))
	parser.add_argument('-rf', '--remove_folder', action='store_true', help='Remove folder if already exists')
	parser.add_argument('-sl', '--framework_static_lib', action='store_true', help="Generate project with framework's static libraries")
	parser.add_argument('-of', '--override_files', action='store_true', help="Override autogenerated files for tempalte project (main.cpp, app.h/cpp, CMakeLists.txt)")

	args = parser.parse_args()

	if args.remote == "none" and args.push == True:
		print("No remote specified. -p/--push option ignored.")
		args.push = False

	return args.name, args.deploy_path, args.remote, args.push, args.generate, args.remove_folder, args.framework_static_lib, args.override_files

def create_folder_if_not_exists(path):
	if not os.path.exists(path):
		os.makedirs(path)

def create_project(project_name, deploy_path, remote, push, framework, remove_folder, framework_static_lib, override_files):
	deploy_path = "{}/{}".format(deploy_path, project_name)

	if remove_folder:
		print("Removing folder under {}".format(deploy_path))
		remove_folder_recursively(deploy_path)

	create_folder_if_not_exists(path_to_os(deploy_path))
	create_folder_if_not_exists(path_to_os("{}/dependencies".format(deploy_path)))

	game_path = "{}/{}".format(deploy_path, project_name.lower())
	create_folder_if_not_exists(path_to_os(game_path))

	repo_already_checked_out = os.listdir(path_to_os(game_path)) != []

	create_folder_if_not_exists(path_to_os("{}/include/application".format(game_path)))
	create_folder_if_not_exists(path_to_os("{}/source/common/application".format(game_path)))

	if repo_already_checked_out == False and subprocess.call('git init', shell=True, cwd=r"{}".format(deploy_path)) != 0:
		message_and_die('Cannot create a git repository in {}'.format(deploy_path))

	if remote != "none":
		if repo_already_checked_out:
			if subprocess.call('git remote set-url origin {}'.format(remote), shell=True, cwd=r"{}".format(deploy_path)) != 0:
				message_and_die('Cannot change repository remote to {} in {}'.format(remote, deploy_path))
		elif subprocess.call('git remote add origin {}'.format(remote), shell=True, cwd=r"{}".format(deploy_path)) != 0:
				message_and_die('Cannot set {} as remote for git repository in {}'.format(remote, deploy_path))

	if repo_already_checked_out == False and subprocess.call('git submodule add https://github.com/jesuslou/LouEngine.git dependencies/LouEngine', shell=True, cwd=r"{}".format(deploy_path)) != 0:
		message_and_die('Cannot add submodule LouEngine!')

	if repo_already_checked_out == False and subprocess.call('git submodule update --init --recursive --force', shell=True, cwd=r"{}".format(deploy_path)) != 0:
		message_and_die('Cannot update submodules!')

	if override_files:
		TemplateProjectFilesGenerator = importlib.import_module("{}.dependencies.LouEngine.build.scripts.TemplateProjectFilesGenerator".format(project_name))
		TemplateProjectFilesGenerator.generate_templated_files(project_name, deploy_path)

	ScriptsGenerator = importlib.import_module("{}.dependencies.LouEngine.build.scripts.ScriptsGenerator".format(project_name))
	generation_platforms = ["win32", "osx"]
	generation_frameworks = ["sfml", "sdl"]
	ScriptsGenerator.create_framework_generate_scripts(project_name, deploy_path, framework_static_lib, generation_frameworks, generation_platforms)

	if push:
		if subprocess.call('git add .', shell=True, cwd=r"{}".format(deploy_path)) != 0:
			message_and_die('Cannot add autogenerated content!')
		if subprocess.call('git commit -m "First commit"', shell=True, cwd=r"{}".format(deploy_path)) != 0:
			message_and_die('Cannot commit!')
		if subprocess.call('git push -u origin master', shell=True, cwd=r"{}".format(deploy_path)) != 0:
			message_and_die('Cannot push to {}!'.format(remote))

	if framework != "none":
		platform = "osx" if os.name == "posix" else "win32"
		print("Deploy finished. Starting project generation for {} [{}]...".format(framework, platform))
		script_name = "{}-debug-{}-update.sh".format(platform, framework)
		generate_folder = path_to_os("{}/generate/{}/{}".format(deploy_path, platform, script_name))
		os.system(generate_folder)

if __name__ == '__main__':
	check_git_in_path()
	check_cmake_in_path()
	name, deploy_path, remote, push, framework, remove_folder, framework_static_lib, override_files = read_parameters()
	create_project(name, deploy_path, remote, push, framework, remove_folder, framework_static_lib, override_files)
